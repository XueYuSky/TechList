# 2-VerilogHDL设计基础知识

VerilogHDL是C语言发展而来的，用于描述数字电路行为与结构的计算机语言。

VerilogHDL适用于系统级(System)、算法级(Algorithm)、寄存器传输级(Register Transfer Level,RTL)、门级(Gate)和开关级(Switch)各个层次的设计与描述。

---

# 2.1 初识VerilogHDL

Verilog HDL 的基本单位： 模块(module)

用于描述某种特定功能电路的结构或行为。模块既可以用于描述门电路，也可以用于描述编码器，译码器，数据选择器，寄存器和计数器等中等规模的数字器件，还可以用于描述整个数字系统。

Verilog HDL模块由模块声明、端口类型定义、数据类型定义、功能描述等多个部分构成。

---
``` Verilog
module Counter_Design
(
	//globol clock
	input				clk,	//50MHz 
	input				rst_n,
	
	//user interface
	output	reg	[3:0]	cnt
);

    //----------------------------
    //Counter for 4 bit data
    always@(posedge clk or negedge rst_n)
    begin
        if(!rst_n)
            cnt <= 0;
        else
            cnt <= cnt + 1'b1;
    end
endmodule

```

下面是上述实例的基本结构说明：

``` Verilog
//格式说明  Verilog——2001标准，将端口类型合并在模块声明中进行定义

module 模块名
(
    //----------------------------------------
    //端口列表
    //--------------------
    //输入端口列表
    input 输入端口列表,
    //输出端口列表
    output 输出入端口列表,
    //双向端口列表
    inout 双向端口列表,
);

    //----------------------------------------
    //数据类型定义
    wire [msb:lsb] 线网名,线网名,……;
    reg  [msb:lsb] 变量名,变量名,……;

    //----------------------------------------
    //函数与任务声明
    function [位宽] 函数名;
    ……
    endfunction

    task 任务名;
    ……
    endtask

    //----------------------------------------
    //功能描述
    assign 线网名=函数表达式;    //数据流描述方式
    always/initial 过程语句;    //行为描述方式
    调用模块名 实例名 (端口关联列表)    //结构描述方式

endmodule
```

## 模块主要组成简要说明：
1. 模块声明
2. 端口类型说明
3. 数据类型定义说明
4. 函数与任务说明
5. 功能描述说明

---

# 2.2 Verilog基本元素
基本语法元素： 空白符，注释，数值和字符串，标识符，关键字词等。

保留了C语言的语法特点，例如: 空白符、注释方法与C语言完全相同，标识符区分大小写等。

与C语言的区别： Verilog本质上是用来描述硬件电路的，例如线网/变量的概念/取值以及操作符等。

## 2.2.1 取值集合
线网/变量的四种基本取值： 1、0、x和z。x和z不区分大小写。


## 2.2.2 常量表示
Verilog的常量： 取值不变的量。

分为： 整形常量、实数常量、字符串三种类型。

1. 整形常量

​    定义格式：

    <±>        <位宽>        '        <基数>        [数值]
    ----       --------     ----      ------       --------
     |           |           |          |            |
     |           |           |          |            |
    指定数值    用十进制     格式符     指定数值      整数的值
    的正负      指定数值               的基数        
               的二级制
               位宽

基数用于指定数值的形式。基数符号和含义如下表：

|  基数符号     |  表示的进制     |  合法数值字符    |
| ----         | ----           | ----            |
|  B或b        |  二进制         |  0, 1, x/X, z/Z, ?和_    |
|  O或o        |  八进制         |  0~7,  x/X, z/Z, ?和_    |
|  D或d        |  十进制         |  0~9,  x/X, z/Z, ?和_    |
|  H或h        |  十六进制       |  0~9, A~F, x/X, z/Z, ?和_ |

**实例：**

``` Verilog
4'b1001        // 四位二进制数，值为1001

5'd123         // 十进制数，位宽为5位，值为23

3'b01x         // 三位二进制数，值为01x

12'hz          // 12位二进制数，每位值为z
```

2. 实数型常量

实数型常数用于仿真中。表示延迟量、仿真时间等物理参数。可以用带小数点的十进制数，也可以用科学计数法表示。

``` Verilog
1.0             // 十进制数，

3.1415926       // 十进制数，

123.45e2        // 科学计数法表示，值为 12345

1.2e-1          // 科学计数法表示，值为0.12
```

3. 字符串

字符串定义为双引号内的字符序列，用ASCII码序列表示。每个字表示为一个8位ASCII码。

Verilog中，字符串保存在reg类型的变量中。

**如果复制过程中，字符串位数超出reg变量的位宽，则会自动截取ASCII码序列最左边的数值，低位对齐（右对齐）。如果字符串的位数小于reg变量的位数，则默认用数值0填补变量左边的空位。**

字符串不能分为多行书写。

4. 参数定义语句

Verilog允许使用参数定义语句定义常量，用标识符来代替常量数值，用于指定数据的位宽、定义参量和状态编码等。

定义格式：
```Verilog
parameter   参数名1 = 数值或表达式1, 参数名2 = 数值或表达式2, ……;
localparam  参数名1 = 数值或表达式1, 参数名2 = 数值或表达式2, ……;
```
参数定义语句只能对参数赋值一次，并且等式右边的表达式必须为常量或者常量表达式，即表达式中只能包含数据和已定义的参数。例如：

``` Verilog
parameter MSB = 7,LSB = 0;        // 定义参数 MSB和LSB，值分别为：7和0
parameter DELAY = 10;             // 定义参数 DELAY,值为10
……
reg [MSB:LSB] reg_a;              // 引用参数MSB和LSB定义位宽
and #DELAY (y,a,b)                // 引用参数DELAY定义延时时间
```
说明：

1) parameter/localparam定义的参数是局部的。参数定义语句应写在模块的内部，只对当前模块起作用；
2) parameter具有参数传递功能，在层次电路的设计中，可以将上层模块的数值传递给下层模块的参数，从而能够调整下层模块的结构与规则，而localparam不具有参数传递功能，因此无法通过外部数值来改变已经顶一顶额参数值。

## 2.2.3 标识符与关键字

标识符是定义Verilog语言结构名称的字符串。

标识符基本规定：

1) 由大小写字母、数字、$和_（下划线）组成
2) 以字母或下划线开头，中间可以使用下划线，但不能连续使用下划线，也不能以下划线结束；
3) 长度小于1024;
4) 标识符区分大小写;

**关键词：**

Verilog 预先保留的用于定义语言结构的特殊符号成为关键词。

1. Verilog的关键词都是小写的。
2. 标识符第一个字符不能是$，  “$”专门用来表示系统命令，如系统任务和函数。

Verilog特殊标识符： 转义标识符，"\"开头，空白符（空格、制表符、或换行符）结束的任意字符串序列。

---

# 2.3 数据类型

数据类型用于定义电路中的物理连线和局哟存储功能的数据单元。

数据类型定义的语法格式为：

    <数据类型>   [符号]          <位宽>      <标识符>     [元素数]
    ----       --------         ----      ------       --------
     |           |                |          |            |
     |           |                |          |            |
     定义网络/    指定符号         定义数据    网络/变量名  定义元素个数
     变量子类型   signed/unsigned  的位宽   


数据类型分为：线网类型和变量两大类
详见： Page32

## 2.3.1 线网类型

## 2.3.2 变量类型

变量用于定义具有存储作用的数据单元，由寄存器变量，整形变量，实数型变量，时间变量和实时间变量五种子类型。

## 2.3.3 存储器

由寄存器变量构成的数组。
定义格式：
```Verilog
reg [n-1:0]  存储器名  [m-1:0];
```
[n-1:0]表示每个存储单元的位宽为n,而[m-1:0]表示存储器共有m个存储单元。
例如：
```verilog
reg [9:0] sine_rom [1023:9];   // 每个单元的位宽为10位，共有1024个存储单元
```


## 2.3.4 标量与矢量

标量：位宽为一位的线网/变量称为标量。

矢量：位宽大于一位的线网/变量称为标量。

标量类矢量：可按位或者部分位赋值的矢量。用关键词：scalared表示。相当于多个一位标量的集合。

矢量类矢量：不能按位或者部分位赋值的矢量，用关键词： vectored表示。

```verilog
reg scalared [7:0] Qtmp;
wire vectored [15:0] bus16b;
```

---

# 2.4 运算符与操作符

按功能分为9大类的操作符(运算符)。

参考 Page 35,36页。

---

# 2.5 模块功能的描述方法

Verilog中的模块表示电路实体。主要可以应用：

---- 行为描述方法：描述模块逻辑功能

---- 数据流描述方法： 描述模块逻辑关系

---- 结构描述方法： 描述模块内部器件之间的链接关系

## 2.5.1 行为描述

以过程语句为基本单位。模块可以用一个或者多个过程语句描述其行为特性，但过程语句不能嵌套使用。过程语句有两种形式： 

1. inital语句

语句格式：

```verilog
initial
    begin
        块内变量说明；
        [时序控制1] 语句1;
        ...
        [时序控制n] 语句n;
    end
```

模块中存在两个以上的initial语句时，同时从0时刻开始执行。

2. always语句

```verilog
always @ (事件列表)
    begin [:语句块名]
        块内变量说明；
        [时序控制1] 语句1;
        ...
        [时序控制n] 语句n;
    end    
```
其中，事件列表表示启动always过程语句执行的条件，分为电平敏感事件和边沿触发事件两种类型。

电平敏感事件是指当线网/变量的电平发生变化时进入执行状态，其语法格式：
```verilog
always @ (D0 or D1 or D2 or D3 or A)
    begin
    ...
    end
```
Verilog-2001标准中，事件列表的关键词"or"可以用","代替。
还提供了" always @ (*) "和 " always @*"两种隐式敏感量列表方式，表示将过程语句中所有参与复制的线网/变量都添加到敏感量列表中。

边沿触发事件是指线网/变量发生边沿跳变时执行语句块，分为上升沿触发和下降沿触发两种。分别用posedge和negedge表示。
**注意**：always事件列表中，电平敏感事件和边沿触发事件不能混合使用。

3. 语句块(block)定义：

语句块是将多条语句组合在一起，使其形式上类似一条语句，作用于C语言的"{}"相同。

有顺序语句块和并行语句块两种类型。

* 顺序语句块： 由 begin ... endd 定义
```verilog
begin [:块名]
    语句 1;
    ...
    语句n;
end
```

* 并行语句块： 由 fork ... join 定义
```verilog
fork [:块名]
    语句 1;
    ...
    语句n;
join
```
**关于执行时间的区别：** 

begin ... end : 按语句块的书写顺序执行块中语句，若使用延迟，每条语句的延迟时间均相对于上一条语句的执行时刻而言。

fork ... end : 所有语句块从块被调用的时刻同时开始执行。若使用延迟，则每条语句的延迟时间均相对于块调用的开始时刻而言，与语句的具体书写顺序无关。

4. 延时控制

用于定义从开始遇到语句到真正执行该语句的等待时间。延时控制只用于仿真，综合时所有延时控制将被忽略。

两种书写形式，常规延时和内嵌延时：

常规延时格式：

[#延时量] 线网/变量 = 表达式;

内嵌延时格式：

线网/变量 = [#延时量] 表达式;

延时量的单位由预编译处理语句" `timescale "进行定义。

```verilog
`timescale 1ns/100ps
```

表示仿真时间单位为1ns,仿真精度为100ps。

5. 过程赋值语句

过程赋值语句是指在inital/always过程语句内部对变量进行赋值的赋值语句。

语法格式：
```verilog
<变量>  <赋值操作符>  <赋值表达式>
```

赋值操作符分为两类：

阻塞赋值： “=”

非阻塞赋值： “<=”

需要重点注意阻塞赋值和非阻塞赋值的区别，深刻体会两种赋值操作对电路产生的影响： 阻塞式赋值在多条赋值语句赋值时，书写顺序非常关键，结果与书写顺序有关；而非阻塞式赋值在多条赋值语句赋值时，多条赋值语句同时赋值，与语句的顺序无关，这样能够**实现并行操作**。

用以下实例对比体会两种赋值语句的区别：

```verilog
module blocking
    (
        input din,
        input clk,
        output	reg	reg1,
        output	reg	 reg2
    )
    always @ (posedge clk)
        begin
            reg1 = din;      // 阻塞式赋值
            reg2 = reg2;     // 阻塞式赋值
        end
endmodule
```

```verilog
module blocking
    (
        input din,
        input clk,
        output	reg	reg1,
        output	reg	 reg2
    )
    reg reg1,reg2;

    always @ (posedge clk)
        begin
            reg1 <= din;     // 非阻塞式赋值
            reg2 <= reg2;    // 非阻塞式赋值
        end
endmodule
```
**总结：**

两条著名Verilog设计规范：

一般，用过程语句描述组合逻辑时建议使用阻塞赋值，描述时序逻辑时使用非阻塞赋值。

注意：同一个过程语句不能同时使用阻塞式和非阻塞式赋值。当模块中同时包含组合逻辑和时序逻辑时，应将两种逻辑电路分开进行描述，用一个always语句描述组合逻辑，用另一个always语句描述时序逻辑，或者改用连续赋值语句描述组合逻辑。

关于过程赋值与连续赋值的概念：

连续赋值： 表达式的值发生变化时，被赋值线网的值会立即更新，即其赋值过程是连续进行的。

过程赋值： 只有当事件列表中有事件发生时才能执行过程体中的赋值语句，过程体中变量的值才会被更新。这些变量经过赋值后，其值将保持到下一次赋值为止。

6. 高级程序语句

用于控制代码的流向。

分为： 条件语句、分支语句和循环语句。

(1) 条件语句

* 简单条件语句格式

```verilog
if(条件表达式) 
    条件表达式为真时执行的语句块;
```

**注意:** 当语句在逻辑上不晚上，会引入锁存器，从而会综合出时序电路。

* 分支条件

```verilog
if(条件表达式) 
    条件表达式为真时执行的语句块;
else
    条件表达式为假时执行的语句块;
```

* 多重条件语句(多用于多路选择)

```verilog
if(条件表达式1) 
    条件表达式1为真时执行的语句块;
else if(条件表达式2)  
    条件表达式2为真时执行的语句块;
...
else if(条件表达式n)  
    条件表达式n为真时执行的语句块;
else  
    条件表达式1~n全部为假时执行的语句块;
```
这样的判断，隐含有优先级关系。常用于描述有优先级的逻辑电路。

(2) 分支语句

关键词： case ... endcase,   用于实现多路选择。

语法格式：

```verilog
case (表达式)
    列出值1:语句块1;     //第一分支
    列出值2:语句块2;     //第二分支
    ...
    列出值n:语句块n;     //第n分支  
    [default: 语句块n+1;]    // 默认项
endcase
```

分支语句执行了分支语句后直接退出，不像C语言需要加break才能退出。

分支语句中的各分支是并行的，没有优先级区别。

其它两种分支语句: 

* casez ... endcase
* casex ... endcase

在Verilog中，通常用"?"代替字符x和z,表示无关位。

(3) 循环语句

四种循环语句：

* for
* while
* repeat
* foever

《EDA技术基础教程》  Page 54-56

## 2.5.2 数据流描述

数据流描述采用连续赋值语句，基于表达式描述线网的功能，用于组合逻辑电路的描述。

语法格式为：

```verilog
assign [#延迟量] 线网名= 赋值表达式
```
"[]"为可选项，"="连续赋值操作符。

**注意：**
* 连续赋值语句用于对线网赋值，不能对变量赋值。
* 连续赋值语句和过程赋值语句为平等关系，不能相互嵌套使用
* 连续赋值语句与过程语句时并行的，与书写顺序无关。
* 延迟量只用于仿真，综合时所有的延迟量均被忽略。

实例1：数据流描述2选1数据选择器

```verilog

```

实例2：数据流描述**全加器**

```verilog

```

实例3：数据流描述八位加法器

```verilog

```

实例4：数据流描述四位乘法器

```verilog

```

## 2.5.3 结构描述

结构描述(Structural Modeling):类似于原理图设计，只是将电路中的模块与模块，模块与基元之间的连接关系由连线转换为文字表达。

Verilog 预定义了26个门级原语(primitives,基元)，包括逻辑门和三态门，上下拉电阻，以及MOS开关和双向开关。

六种基元类型：

* 多输入门： and,nand,or,nor,xor,xnor
* 多输出门： buf,not
* 三态门： bufif0,bufif1,notif0,notif1
* 上拉电阻/下拉电阻： pullup,pulldown
* MOS开关：cmos,nmos,pmos,rcmos,rnmos,rpmos
* 双向开关： tran,tranif0,tranif1,rtran,rtranif0,rtranif1

**例化：**
是指使用基元或者已定义的模块创建新对象的过程。被创建的对象成为实例(Instance)。

调用基元的例化语法格式：

```verilog
基元名 [实例名] (端口 1,端口 n,...,端口 n)
```

## 2.5.4 混合描述方法

同一模块中，混合使用过程语句，连续赋值语句和例化语句。

## 2.5.5 用户自定义原语

用户自定义原语(UDP): 设计者根据需要自己规划所需要的功能电路。

以真值表/状态表为基础，将真值表/状态表描述的逻辑关系映射到存储器中实现功能电路。

使用限制： 只允许有一个输出口，且在真值表/状态表中，应尽可能完整的定义出所有的逻辑状态。

语法格式：

```verilog
primitive <UDP名> (输出信号,输入信号,...)
    <输出/输入信号声明>
    initial <输出信号=初值>
    table
        <真值表/状态表>;
        ...
    endtable
endprimitive
```

使用UDP描述组合逻辑电路时，真值表必须按照输入/输出的顺序排序，语法格式如下：

```verilog
<输入信号1> ... <输入信号n>: <输出信号>
```

使用UDP描述时序逻辑电路时，电路的输出必须定义为reg类型。还可以使用inital语句设定输出信号的起始值。语法格式如下：

```verilog
<输入信号1> ... <输入信号n>: <输出信号的现态> : <输出信号的次态>
```
实例：UDP定义边沿D触发器

```verilog
primitive DFF_pr(Q,D,CLK)
    output Q;
    reg Q;
    input D,CLK
    table
      // D ,    CLK   : Q(n)   :Q(n-1)
        0      (01) :    ?    :    0;    //上升沿时
        1      (01) :    ?    :    1;
        0      (0?) :    0    :    0;
        1      (0?) :    1    :    1;
        ?      (?1) :    ?    :    -;    //下降沿时
        ?      (??) :    ?    :    -;    //CLK为电平状态
    endtable
endprimitive
```
**说明：**
上升沿，下降沿的表示，状态不变的表示。

别名与符号对照表

|  别名         |   代表符号     |   说明         |
| ----         | ----           | ----           |
|  b           |  0或1             |   除x之外的逻辑状态      |
|  r           |  01               |   上升沿                |
|  f           |  10               |   下降沿                |
|  p           |  01/0x/x1/1z/z1   |   包含未知的上升沿触发(posedge)    |
|  n           |  10/1x/x0/0z/z0   |   包含未知的下降沿触发(posedge)    |
|  *           |  ??               |   所有状态              |

---

# 2.6 层次化设计方法

模块例化是实现层次化设计的基本方法。

层次化电路设计中，被例化的模块习惯上称为子模块。子模块例化的语法格式：

```verilog
子模块名    实例名    (端口关联列表);
```
端口关联列表用于说明： 子模块与实例端口的连接关系。有两种方式：

(1) 名称关联方式

语法格式：

```verilog
.子模块端口1 (实例端口名),...,.子模块端口n (实例端口名);
```

实例：
```verilog
DFF dff1 (.Q(Q),.Qbar(),.Din(D),.Preset(),.Clock(CLK))
```

括号里是空的，表示两个端口悬空未连接。

(2) 位置关联方式

把实例模块的端口名按子模块定义时的端口顺序排放就能自动映射到子模块的对应端口。

位置关联端口列表语法格式：

```verilog
(实例端口1,实例端口2,...,实例端口n)
```

实例：
```verilog
DFF dff2 (Q, , D, , CLK)
```
在工程中，建议使用名称管理方式，增加带的可读性。

----

文件包含语句

----

语法格式：

```verilog
`include "被包含的模块文件名"
```

使用文件包含语句应注意：

(1) 一条 "`inlcude"语句只能包含一个文件。多个文件包含时，需要用多条 "`inlcude"语句描述。

(2) 被包含模块需要写出完整的文件名信息,包括文件类型名;

(3) 如果被包含的文件不在当前工程目录中时,需要指明文件的完整路径。

(4) 当被包含的文件处于当前工程目录中时，文件包含语句的描述时可以删掉的。但添加该语句的好处是能够使模块之间的相互关系更为清晰。

---

# 2.7 函数与任务

函数与任务是Verilog的两种形式的子程序。可以在模块中进行调用，使描述代码有更好的可阅读性、可移植性、可维护性。既能节约开发时间，也能减少出错概率。

# 2.7.1 函数

函数是具有独立运算功能的单元电路，每次调用根据输入重新计算输出结果。

语法格式：

```verilog
function [位宽] 函数名;
    端口声明;
    语句;
    语句;
    ...
endfunction
```

位宽省略时，默认函数返回值为1位。

定义函数时需要注意：

(1) 函数只能在模块内定义，但不能定义在过程体中。

(2) 函数没有输出端口声明，但可以有多个输入端口声明。

(3) 函数体内可以调用函数体，但不能调用任务。

函数调用语法：

```verilog
<变量名>  =  <函数名>(函数参数,......)
```

对函数的调用是通过函数名完成的。函数名在函数体中代表一个变量，函数调用的返回值是通过函数名变量传递给调用语句的。


# 2.7.2 任务

任务以task开始，以endtask结束。
具体语法格式：

```verilog
task 任务名;
    端口声明；
    语句;
    语句;
    ......
endtask
```

定义任务时需要注意：

(1) task定义语句的首行不列出端口名称

(2) 任务的端口数量没有限制，也可以没有端口

(3) 在task定义中不能包含过程语句。

调用任务时，自变量的排序必须与任务定义时参数的顺序一致。任务还可以调用其他任务。

任务允许有许多个输出，并且允许有延迟、时间或事件控制。因此任务比函数应用更广泛。

---

# 2.8 编写testbench

测试平台文件---- testbench。

为被测模块施加激励信号，通过仿真软件计算被测模块的输出，并传回暑促结果供设计者进行分析。

testbench文件与可综合模块的区别：

(1) testbench既没有输入，也没有输出，而是将被测模块的输入定义为内部寄存器变量，将被测模块的输出定义为内部线网信号；

(2) testbench用于仿真分析,不需要综合,可以使用所有Verilog定义的所有语句来编写代码。而设计功能模块只能用可综合的语句进行描述。

testbench的基本结构为：
```verilog
`timescale 仿真时间单位/仿真精度

module module_tb();

    //testbench没有输入输出端口

    reg 变量名1,...,变量名n;
    wire 线网名1,...,线网名n;

    应用过程语句 initial/always 描述激励信号波形;
    例化被测模块, 传递输入激励并接收输出;
    调用系统任务显示输出信号波形;

endmodule
```

注意：  仿真时间单位≥仿真精度;   仿真精度若取值过小,会加长仿真的执行时间。

Verilog 预定义的系统任务与函数均以 "$" 开头，以区分用户定义的任务和函数。

仿真分析时，常用以下几类系统任务和函数。

## 2.8.1 $display 和 $write 任务

TODO： 待补充实例

## 2.8.2 $monitor 任务

TODO： 待补充实例

## 2.8.3 $time 和 $timeformat 任务

TODO： 待补充实例

## 2.8.4 $finish 和 $stop 任务

TODO： 待补充实例

---
